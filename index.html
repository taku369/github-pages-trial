<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hello GitHub Pages</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; padding: 0; display: grid; place-items: center; min-height: 100vh; }
      main { text-align: center; padding: 2rem; }
      h1 { font-size: clamp(2rem, 6vw, 3rem); margin: 0 0 0.5rem; }
      p { margin: 0.5rem 0 0; opacity: 0.8; }
      footer { position: fixed; inset: auto 0 0; text-align: center; padding: 0.75rem; font-size: 0.85rem; opacity: 0.7; }
      a { color: inherit; }
      /* background canvas behind content */
      #bg-canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; z-index: -1; pointer-events: none; }
    </style>
  </head>
  <body>
    <canvas id="bg-canvas" aria-hidden="true"></canvas>
    <main>
      <h1>Hello, GitHub Pages!</h1>
      <p>とりあえずのサンプルページです。</p>
    </main>
    <footer>
      このページは GitHub Pages で公開できます。
    </footer>
    <script>
      (function() {
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');

        let devicePixelRatioScale = 1;
        function resizeCanvas() {
          const { innerWidth, innerHeight, devicePixelRatio } = window;
          devicePixelRatioScale = Math.min(2, devicePixelRatio || 1);
          canvas.width = Math.floor(innerWidth * devicePixelRatioScale);
          canvas.height = Math.floor(innerHeight * devicePixelRatioScale);
          canvas.style.width = innerWidth + 'px';
          canvas.style.height = innerHeight + 'px';
          ctx.setTransform(devicePixelRatioScale, 0, 0, devicePixelRatioScale, 0, 0);
        }

        const circles = [];
        function random(min, max) { return Math.random() * (max - min) + min; }

        function spawnCircle() {
          const w = window.innerWidth;
          const h = window.innerHeight;
          const maxRadius = Math.max(w, h) * 0.08; // up to 8% of viewport
          const minRadius = Math.max(20, Math.min(w, h) * 0.01);
          const radius = random(minRadius, maxRadius);
          const x = random(-radius, w + radius);
          const y = random(-radius, h + radius);
          const hue = Math.floor(random(0, 360));
          const sat = Math.floor(random(60, 85));
          const light = Math.floor(random(55, 75));
          const color = `hsla(${hue} ${sat}% ${light}% / 1)`;
          const lifeMs = random(6000, 12000); // 6-12s
          const fadeInPortion = 0.25; // 25% fade in, 50% hold, 25% fade out
          const fadeOutPortion = 0.25;
          const createdAt = performance.now();
          circles.push({ x, y, radius, color, lifeMs, fadeInPortion, fadeOutPortion, createdAt });
        }

        let lastSpawn = 0;
        function animate(now) {
          requestAnimationFrame(animate);
          const w = canvas.width / devicePixelRatioScale;
          const h = canvas.height / devicePixelRatioScale;
          ctx.clearRect(0, 0, w, h);

          // spawn new circles at a gentle cadence
          if (now - lastSpawn > 400) { // every ~0.4s
            lastSpawn = now;
            // spawn 1-3 at a time with small probability bursts
            const count = Math.random() < 0.2 ? Math.floor(random(2, 4)) : 1;
            for (let i = 0; i < count; i++) spawnCircle();
          }

          // draw and filter out expired circles
          for (let i = circles.length - 1; i >= 0; i--) {
            const c = circles[i];
            const age = now - c.createdAt;
            if (age >= c.lifeMs) { circles.splice(i, 1); continue; }

            const t = age / c.lifeMs; // 0 → 1
            let alpha;
            if (t < c.fadeInPortion) {
              alpha = t / c.fadeInPortion; // fade in
            } else if (t > 1 - c.fadeOutPortion) {
              alpha = (1 - t) / c.fadeOutPortion; // fade out
            } else {
              alpha = 1; // hold
            }
            // soften overall
            alpha *= 0.25; // global softness

            ctx.globalAlpha = alpha;
            const gradient = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.radius);
            gradient.addColorStop(0, c.color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        requestAnimationFrame(animate);
      })();
    </script>
  </body>
  </html>



